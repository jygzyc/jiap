package jadx.plugins.jiap

import io.javalin.Javalin
import io.javalin.http.Context
import io.javalin.http.bodyAsClass
import jadx.api.plugins.JadxPluginContext
import jadx.gui.ui.MainWindow

import java.util.concurrent.ScheduledExecutorService
import java.util.concurrent.TimeUnit
import kotlin.collections.mapOf

import jadx.plugins.jiap.service.CommonService
import jadx.plugins.jiap.service.AndroidFrameworkService
import jadx.plugins.jiap.service.AndroidAppService
import jadx.plugins.jiap.model.JiapResult
import jadx.plugins.jiap.utils.JiapConstants
import jadx.plugins.jiap.utils.PreferencesManager
import jadx.plugins.jiap.utils.ParameterConverter
import jadx.plugins.jiap.utils.LogUtils

class JiapServer(
    private val pluginContext: JadxPluginContext,
    private val scheduler: ScheduledExecutorService
) {
    
    companion object {
        // 时间常量 (毫秒)
        private const val SHUTDOWN_TIMEOUT_MS = 500L
        private const val RESTART_DELAY_MS = 1000L
        private const val PORT_RELEASE_TIMEOUT_MS = 2000L

        // 初始化常量 (秒)
        private const val INIT_CHECK_INTERVAL_SECONDS = 1L
        private const val INITIAL_DELAY_SECONDS = 2L
        private const val MAX_INIT_WAIT_SECONDS = 30L
    }

    private var started = false
    private lateinit var app: Javalin

    // 防止重复初始化
    private var initializationScheduled = false

    private val commonService: CommonService = CommonService(pluginContext)
    private val androidFrameworkService: AndroidFrameworkService = AndroidFrameworkService(pluginContext)
    private val androidAppService: AndroidAppService = AndroidAppService(pluginContext)
    
    @Synchronized
    fun start(port: Int = JiapConstants.DEFAULT_PORT) {
        // Prevent duplicate start
        if (started) {
            LogUtils.warn(LogUtils.Msg.SERVER_ALREADY_RUNNING, PreferencesManager.getPort())
            return
        }

        // Ensure JADX is loaded
        if (!isJadxDecompilerAvailable()) {
            LogUtils.error(LogUtils.Msg.JADX_NOT_AVAILABLE)
            throw IllegalStateException(LogUtils.Msg.JADX_NOT_AVAILABLE)
        }

        try {
            LogUtils.info(LogUtils.Msg.SERVER_STARTING, port)
            app = Javalin.create().start(port)
            PreferencesManager.setPort(port)
            configureRoutes()
            started = true
            initializationScheduled = false // 重置初始化标记
            LogUtils.info(LogUtils.Msg.SERVER_STARTED, port)

            setupShutdownHook()
        } catch (e: Exception) {
            started = false
            LogUtils.error(LogUtils.Msg.SERVER_START_FAILED, e)
            throw RuntimeException(LogUtils.Msg.SERVER_START_FAILED, e)
        }
    }

    @Synchronized
    fun stop() {
        if (!started) {
            LogUtils.serverAlreadyStopped()
            return
        }

        started = false

        try {
            if (this::app.isInitialized) {
                app.stop()
                Thread.sleep(SHUTDOWN_TIMEOUT_MS)
            }
            LogUtils.serverStopped()
        } catch (e: Exception) {
            LogUtils.serverStopFailed(e)
        }
    }

    /**
     * 设置JVM关闭钩子
     */
    private fun setupShutdownHook() {
        Runtime.getRuntime().addShutdownHook(Thread({
            try {
                LogUtils.shutdownHookTriggered()
                stop()
            } catch (e: Exception) {
                LogUtils.shutdownError(e)
            }
        }, "JiapServer-ShutdownHook"))
    }

    fun restart() {
        // 如果未运行，直接启动
        if (!started) {
            LogUtils.serverNotRunning()
            start(PreferencesManager.getPort())
            return
        }

        // 异步重启，避免阻塞
        Thread({
            try {
                LogUtils.serverRestarting()
                stop()
                Thread.sleep(RESTART_DELAY_MS)
                start(PreferencesManager.getPort())
            } catch (e: Exception) {
                LogUtils.serverRestartFailed(e)
                started = false
            }
        }, "JiapServer-Restart").apply {
            isDaemon = true // 设置为守护线程
        }.start()
    }

    fun getCurrentPort(): Int {
        return PreferencesManager.getPort()
    }

    fun isRunning(): Boolean {
        return started
    }

    @Synchronized
    fun delayedInitialization() {
        if (initializationScheduled) {
            LogUtils.debug("JIAP: Initialization already scheduled")
            return
        }
        initializationScheduled = true

        LogUtils.info("JIAP: Starting delayed initialization")

        scheduleInitializationTask()
        scheduleInitializationTimeout()
    }

    private fun scheduleInitializationTask() {
        scheduler.scheduleAtFixedRate({
            try {
                performInitializationCheck()
            } catch (e: Exception) {
                LogUtils.error("JIAP: Error during initialization check", e)
            }
        }, INITIAL_DELAY_SECONDS, INIT_CHECK_INTERVAL_SECONDS, TimeUnit.SECONDS)
    }

    private fun performInitializationCheck() {
        when {
            started -> {
                LogUtils.info("JIAP: Server started, stopping initialization checker")
                shutdownSchedulerSafely()
            }
            isJadxDecompilerAvailable() -> {
                LogUtils.info("JIAP: JADX decompiler ready, starting server...")
                restart()
                shutdownSchedulerSafely()
            }
            else -> {
                LogUtils.debug("JIAP: Waiting for JADX decompiler...")
            }
        }
    }

    private fun scheduleInitializationTimeout() {
        scheduler.schedule({
            if (!started) {
                LogUtils.warn("JIAP: ${ErrorMessages.JADX_INIT_TIMEOUT}")
            }
        }, MAX_INIT_WAIT_SECONDS, TimeUnit.SECONDS)
    }

    /**
     * 安全关闭调度器
     */
    private fun shutdownSchedulerSafely() {
        try {
            scheduler.shutdown()
            if (!scheduler.awaitTermination(1, TimeUnit.SECONDS)) {
                scheduler.shutdownNow()
            }
        } catch (e: InterruptedException) {
            Thread.currentThread().interrupt()
            scheduler.shutdownNow()
        } catch (e: Exception) {
            LogUtils.error("JIAP: Error shutting down scheduler", e)
        }
    }

    private fun isJadxDecompilerAvailable(): Boolean {
        return try {
            // 检查GUI上下文
            val guiContext = pluginContext.guiContext
            if (guiContext != null) {
                val mainFrame = guiContext.mainFrame
                if (mainFrame is MainWindow) {
                    val wrapper = mainFrame.wrapper
                    val classes = wrapper.includedClassesWithInners
                    if (classes == null) {
                        LogUtils.debug("JIAP: No classes available")
                        return false
                    }
                } else {
                    LogUtils.debug("JIAP: Main frame is not MainWindow instance")
                }
            }

            // 检查反编译器
            val decompiler = pluginContext.decompiler
            if (decompiler == null) {
                LogUtils.debug("JIAP: Decompiler not loaded")
                return false
            }

            val classCount = decompiler.classesWithInners.size
            if (classCount > 0) {
                LogUtils.debug("JIAP: Found $classCount classes, JADX ready")
                true
            } else {
                LogUtils.debug("JIAP: No classes loaded")
                false
            }
        } catch (e: Exception) {
            LogUtils.debug("JIAP: JADX availability check failed: ${e.message}")
            false
        }
    }

    data class RouteTarget(
        val service: Any,
        val methodName: String,
        val params: Set<String> = emptySet()
    ) {
        // Cached method reference, lazily initialized
        @Volatile
        private var cachedMethod: java.lang.reflect.Method? = null

        // Get method reference with caching
        fun getMethod(): java.lang.reflect.Method {
            // Double-checked locking pattern
            if (cachedMethod == null) {
                synchronized(this) {
                    if (cachedMethod == null) {
                        val serviceClass = service::class.java
                        val method = serviceClass.methods.find {
                            it.name == methodName
                        } ?: throw NoSuchMethodException(
                            "Method $methodName not found in ${serviceClass.simpleName}"
                        )
                        cachedMethod = method
                    }
                }
            }
            return cachedMethod!!
        }
    }

    private val routeMap = mapOf(
        // Common Service
        "/api/jiap/get_all_classes" to RouteTarget(
            service = commonService,
            methodName = "handleGetAllClasses"
        ),
        "/api/jiap/selected_text" to RouteTarget(
            service = commonService,
            methodName = "handleGetSelectedText"
        ),
        "/api/jiap/search_method" to RouteTarget(
            service = commonService,
            methodName = "handleSearchMethod",
            params = setOf("method")
        ),
        "/api/jiap/get_class_info" to RouteTarget(
            service = commonService,
            methodName = "handleGetClassInfo",
            params = setOf("class")
        ),
        "/api/jiap/get_method_xref" to RouteTarget(
            service = commonService,
            methodName = "handleGetMethodXref",
            params = setOf("method")
        ),
        "/api/jiap/get_class_xref" to RouteTarget(
            service = commonService,
            methodName = "handleGetClassXref",
            params = setOf("class")
        ),
        "/api/jiap/get_implement" to RouteTarget(
            service = commonService,
            methodName = "handleGetImplementOfInterface",
            params = setOf("interface")
        ),
        "/api/jiap/get_sub_classes" to RouteTarget(
            service = commonService,
            methodName = "handleGetSubclasses",
            params = setOf("class")
        ),
        "/api/jiap/get_class_source" to RouteTarget(
            service = commonService,
            methodName = "handleGetClassSource",
            params = setOf("class", "smali")
        ),
        "/api/jiap/get_method_source" to RouteTarget(
            service = commonService,
            methodName = "handleGetMethodSource",
            params = setOf("method", "smali")
        ),

        // Android App Service
        "/api/jiap/get_app_manifest" to RouteTarget(
            service = androidAppService,
            methodName = "handleGetAppManifest"
        ),
        "/api/jiap/get_main_activity" to RouteTarget(
            service = androidAppService,
            methodName = "handleGetMainActivity"
        ),

        // Android Framework Service
        "/api/jiap/get_system_service_impl" to RouteTarget(
            service = androidFrameworkService,
            methodName = "handleGetSystemServiceImpl",
            params = setOf("interface")
        )
    )
    
    private fun configureRoutes() {
        // Health check endpoint
        app.get("/health") { ctx ->
            handleHealthCheck(ctx)
        }
        routeMap.keys.forEach { path ->
            app.post(path) { ctx ->
                handleRoute(ctx, path)
            }
        }
    }

    private fun handleRoute(ctx: Context, path: String) {
        try{
            val operation = path.substringAfterLast("/")
            LogUtils.debug("JIAP: Processing request: $operation")
            val routeTarget = routeMap[path]
                ?: throw IllegalArgumentException(ErrorMessages.UNKNOWN_ENDPOINT.format(path))
            val payload = ctx.bodyAsClass<Map<String, Any>>()
            val isValid = validateRequiredParams(payload, routeTarget.params, ctx)
            if (isValid == false) return
            val result = invokeServiceMethod(routeTarget, payload)
            handleServiceResult(result, ctx)
        }catch (e: Exception) {
            handleRouteError(ctx, e, path)
        }
    }

    private fun validateRequiredParams(
        payload: Map<String, Any>,
        requiredParams: Set<String>,
        ctx: Context
    ): Boolean? {
        for (param in requiredParams) {
            if (payload[param] == null || payload[param].toString().isBlank()) {
                ctx.status(400).json(mapOf(
                    "error" to ErrorMessages.missingParameter(param)
                ))
                return false
            }
        }
        return true
    }

    private fun invokeServiceMethod(
        routeTarget: RouteTarget,
        payload: Map<String, Any>
    ): JiapResult {
        // Get cached method
        val method = routeTarget.getMethod()

        // Prepare arguments
        val args = method.parameters.map { param ->
            val paramName = param.name ?: "param${method.parameters.indexOf(param)}"
            ParameterConverter.convertValue(payload[paramName], param.type)
        }.toTypedArray()

        // Invoke method
        @Suppress("UNCHECKED_CAST")
        return method.invoke(routeTarget.service, *args) as JiapResult
    }

    private fun handleRouteError(ctx: Context, e: Exception, path: String) {
        val message = when (e) {
            is IllegalArgumentException -> e.message ?: "Invalid request"
            is NoSuchMethodException -> e.message ?: "Method not found"
            else -> "${ErrorMessages.INTERNAL_SERVER_ERROR}: ${e.message}"
        }

        ctx.status(500).json(mapOf(
            "error" to message,
            "path" to path
        ))
    }

    fun handleHealthCheck(ctx: Context) {
        try {
            val running = started
            val status = if (running) "Running" else "Stopped"
            val port = PreferencesManager.getPort()
            val url = if (running) "http://127.0.0.1:$port/" else "N/A"

            val result = mapOf(
                "status" to status,
                "url" to url,
                "port" to port,
                "timestamp" to System.currentTimeMillis()
            )

            ctx.status(200).json(result)
        } catch (e: Exception) {
            LogUtils.error("JIAP: Health check failed", e)
            ctx.status(500).json(mapOf(
                "error" to ErrorMessages.INTERNAL_SERVER_ERROR,
                "message" to e.message
            ))
        }
    }

    private fun handleServiceResult(result: JiapResult, ctx: Context) {
        if (result.success) {
            LogUtils.debug("JIAP: Service call completed successfully")
            ctx.json(result.data)
        } else {
            LogUtils.error("JIAP: ${ErrorMessages.SERVICE_CALL_FAILED}")
            ctx.status(500).json(result.data)
        }
    }
}
